
# signals can be generated by functions of time
struct SignalFunction{Fn,Fr}
    fn::Fn
    ω::Fr
    ϕ::Float64
    samplerate::Float64
end
SignalTrait(x::SignalFunction) = IsSignal(x.samplerate)
function Base.iterate(x::SignalFunction,i=0) 
    t = i/x.samplerate
    x.fn(2π*(t*x.ω + x.ϕ)), i+1
end
function Base.iterate(x::SignalFunction{typeof(sin),Float64},i=0) 
    t = i/x.samplerate
    sinpi(2*(t*x.ω + x.ϕ)), i+1
end
function Base.iterate(x::SignalFunction{<:Any,Nothing},i=0)
    t = i/x.samplerate
    x.fn(t + x.ϕ), i+1
end
    
function signal(x::Function,samplerate;
    ω=nothing,frequency=ω,ϕ=0,phase=ϕ)

    SignalFunction(x,inHz(ω),inradians(ϕ)/2π,inHz(samplerate))
end

signal(x::typeof(randn),fs=nothing) = SignalFunction(x,nothing,0.0,0.0)
function Base.iterate(x::SignalFunction{typeof(randn)},i=0)
    randn(), 0
end

signal(fn::typeof(zero),x) = signal(fn,x,SignalTrait(x))
function signal(fn::typeof(zero),x,::IsSignal)
    signal(zero(signal_eltype(x)),samplerate(x))
end
signal(fn::typeof(zero),x,::Nothing) = error("Value is not a signal: $x")

signal(fn::typeof(one),x) = signal(fn,x,SignalTrait(x))
function signal(fn::typeof(one),x,::IsSignal)
    signal(one(signal_eltype(x)),samplerate(x))
end
signal(fn::typeof(one),x,::Nothing) = error("Value is not a signal: $x")