<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · SignalOperators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SignalOperators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Manual</a><ul class="internal"><li><a class="toctext" href="#Piping-1">Piping</a></li><li><a class="toctext" href="#Units-1">Units</a></li><li><a class="toctext" href="#Infinite-lengths-1">Infinite lengths</a></li><li><a class="toctext" href="#Unspecified-sample-rates-1">Unspecified sample rates</a></li><li><a class="toctext" href="#Signal-promotion-1">Signal promotion</a></li><li class="toplevel"><a class="toctext" href="#Signal-generation-1">Signal generation</a></li><li><a class="toctext" href="#Numbers-1">Numbers</a></li><li><a class="toctext" href="#Arrays-1">Arrays</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li class="toplevel"><a class="toctext" href="#Signal-inspection-1">Signal inspection</a></li><li class="toplevel"><a class="toctext" href="#Signal-manipulation-1">Signal manipulation</a></li><li><a class="toctext" href="#Extending-1">Extending</a></li><li><a class="toctext" href="#Cutting-1">Cutting</a></li><li><a class="toctext" href="#Filtering-1">Filtering</a></li><li><a class="toctext" href="#Ramping-1">Ramping</a></li><li><a class="toctext" href="#Mapping-1">Mapping</a></li></ul></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Manual</a></li></ul><a class="edit-page" href="https://github.com/haberdashPI/SignalOperators.jl/blob/master/docs/src/manual.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><p>SignalOperators is a package that aims to provide a clean interface for generating and manipulating regularly sampled signals, typically sounds. </p><h1><a class="nav-anchor" id="Key-concepts-1" href="#Key-concepts-1">Key concepts</a></h1><p>There are several important concepts employed across the public interface. Let&#39;s step through one of the examples from the homepage (and README.md), which demonstrates most of these concepts. </p><pre><code class="language-julia">sound1 = signal(sin,ω=1kHz) |&gt; until(5s) |&gt; ramp |&gt; normpower |&gt; amplify(-20dB)</code></pre><p>This example creates a 1 kHz pure-tone (sine wave) that lasts 5 serconds. It&#39;s amplitude is 20 dB lower than a signal with unit 1 power. </p><p>There are a few things going on here: piping, the use of units, infinite length signals, and unspecified sample rates </p><h2><a class="nav-anchor" id="Piping-1" href="#Piping-1">Piping</a></h2><p>All of the functions implemented in SignalOperators can be piped. This means that instead of passing the first argument to a signal operator, you can pipe it using <code>|&gt;</code>. For example, the two statements below have the same meaning. </p><pre><code class="language-julia">sound1 = signal(sin,ω=1kHz) |&gt; until(5s)
sound1 = until(signal(sin,ω=1kHz),5s)</code></pre><p>The use of piping makes it easier to read the sequence of operations that are performed on the signal.</p><h2><a class="nav-anchor" id="Units-1" href="#Units-1">Units</a></h2><p>In any place where a signal operator needs a time or a frequency, it can be specified using units. If units are not specified, time is assumed to be in seconds, and frequency in Hertz. So, for example, the following two statements are equivalent. </p><pre><code class="language-julia">sound1 = signal(sin,ω=1kHz)
sound1 = signal(sin,ω=1000)</code></pre><p>Each unit is represented by a constant you can multiply by a number (in Julia, 10ms == 10*ms). To make use of the unit constants you must call <code>using SignalOperators.Units</code>. The units defined are <code>samples</code>, <code>Hz</code>, <code>s</code> <code>kHz</code> <code>ms</code> <code>°</code>, <code>rad</code> and <code>dB</code>. You can just include the ones you want using e.g. <code>using SignalOperators.Units: Hz</code>, or you can include more by adding the <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful</code></a> package to your project and adding the desired units from there. The <code>samples</code> unit is unique to the SignalOperators package and allows you to specify the units of time in terms of the number of samples rather than units of time. </p><p>Note that the output of all functions to inspect a signal (e.g. <code>duration</code>, <code>samplerate</code>) are <code>Float64</code> values in the default unit (seconds or Hertz).</p><h3><a class="nav-anchor" id="decibels-1" href="#decibels-1">decibels</a></h3><p>You can pass an amplification value as unitless or a unitful value in <code>dB</code>, a unitless value is not assumed to be in decibels. Instead it&#39;s assumed to be the actual ratio by which you wish to multiply the signal. E.g. <code>amplify(x,2)</code> will make x twice as loud. </p><h2><a class="nav-anchor" id="Infinite-lengths-1" href="#Infinite-lengths-1">Infinite lengths</a></h2><p>Some of the ways you can define a signal lead to an infinite length signal. You cannot store an infinite signal. It is represented as a function of some kind. Operations on signals are generally lazy, meaning the samples of the signal aren&#39;t evaluated until necessary. To allow actual data to be created from a signal, you have to specify the length, using <a href="../reference/#SignalOperators.until"><code>until</code></a>. For example, when using <code>signal(sin)</code>, the signal is an infinite length sine wave. That&#39;s why, in the example above we use <a href="../reference/#SignalOperators.until"><code>until</code></a> to specify the length, like so: </p><pre><code class="language-julia">signal(sin,ω=1kHz) |&gt; until(5s)</code></pre><p>Infinite lengths are represented as the value <code>inflen</code>. This has overloaded definitions of various operators to play nicely with ordering, arithmetic etc... </p><h2><a class="nav-anchor" id="Unspecified-sample-rates-1" href="#Unspecified-sample-rates-1">Unspecified sample rates</a></h2><p>You may notice that the above signal has no defined sample rate. Such a signal is defined by a function, and can be sampled at whatever rate you desire. If you add a signal to the chain of operations that does have a defined sample rate, the unspecified sample rate will be resolved to that same rate (see Signal promotion, below). If there is no defined sample rate by the time you call <a href="../reference/#SignalOperators.sink"><code>sink</code></a> you can specify it then. ## Sinking</p><p>Once you have defined a signal, you can create some concrete sequence of samples from it. This is done using <a href="../reference/#SignalOperators.sink"><code>sink</code></a>. The resulting value is itself a signal, so you can pass this to other signal operators. The function <a href="../reference/#SignalOperators.sink"><code>sink</code></a> is also used to create a file. Sink must consume a finite-length signal. To store the five second signal in the above example to &quot;example.wav&quot; we could write the following.</p><pre><code class="language-julia">sound1 |&gt; sink(&quot;example.wav&quot;,samplerate=44.1kHz)</code></pre><p>In this case, since <code>sound1</code> had no defined sample rate, we have to tell sink what the sample rate is. If the signal already had a sample rate defined, we could just call <code>sink(&quot;example.wav&quot;)</code>. </p><h2><a class="nav-anchor" id="Signal-promotion-1" href="#Signal-promotion-1">Signal promotion</a></h2><p>A final concept, which may not be as obvious from the examples, is the use of automatic signal promotion. When multiple signals are passed to the same operator, and they have a different element type (e.g. <code>Float32</code> vs <code>Float64</code>), different number of channels, or different sample rate, the signals are first converted to the highest fidelity format and then operated on. This allows for a relatively seamless chain of operations where you don&#39;t have to worry about the specific format of the signal, and you won&#39;t loose information about your signals unless you explicitly request a lower fidelity signal format (e.g. using <a href="@ref"><code>tochannels</code></a> or <a href="@ref"><code>tosamplerate</code></a>). </p><h1><a class="nav-anchor" id="Signal-generation-1" href="#Signal-generation-1">Signal generation</a></h1><p>There are three basic types that can be interpreted as signals: numbers, arrays and functions. Internally the function <a href="../reference/#SignalOperators.signal"><code>signal</code></a> is called on any object passed to a signal operator, you can call this function yourself if you want to specify the exact sample rate by which you want to interpret the signal. </p><h2><a class="nav-anchor" id="Numbers-1" href="#Numbers-1">Numbers</a></h2><p>A number is treated as an infinite length signal, with unknown sample rate. </p><pre><code class="language-julia">1 |&gt; until(1s) |&gt; sink(samplerate=10Hz) == ones(10)</code></pre><h2><a class="nav-anchor" id="Arrays-1" href="#Arrays-1">Arrays</a></h2><p>A standard array is treated as a finite signal, with unknown sample rate.</p><pre><code class="language-julia">rand(10,2) |&gt; sink(samplerate=10Hz) |&gt; duration == 1</code></pre><p>An <code>AxisArray</code> is treated as a finite signal with a known sample rate (and is the default output of <a href="../reference/#SignalOperators.sink"><code>sink</code></a>) </p><pre><code class="language-julia">using AxisArrays
x = AxisArray(rand(10,1),Axis{:time}(range(0,1,length=10)))
samplerate(x) == 10</code></pre><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><p>A function is can be treated as an infinite signal. It should take a single argument which is the time in radians (<em>not</em> seconds). Radians are used to make defining the frequency of the signal for typical functions (e.g. sin), which is defind using the keywored argument <code>ω</code> or <code>frequency</code>. See <a href="../reference/#SignalOperators.signal"><code>signal</code></a>&#39;s documentation for more detail&#39;s.</p><pre><code class="language-julia">signal(sin,ω=1kHz) |&gt; duration |&gt; isinf == true</code></pre><p>An exception to this is <code>randn</code>. It can be used directly as a signal with unknown sample rate. </p><pre><code class="language-julia">randn |&gt; duration == isinf</code></pre><h1><a class="nav-anchor" id="Signal-inspection-1" href="#Signal-inspection-1">Signal inspection</a></h1><p>You can examine the properties of a signal using <a href="../reference/#SignalOperators.nsamples"><code>nsamples</code></a>, <a href="../reference/#SignalOperators.nchannels"><code>nchannels</code></a>, <a href="../reference/#SignalOperators.samplerate"><code>samplerate</code></a>, and <a href="../reference/#SignalOperators.duration"><code>duration</code></a>.</p><h1><a class="nav-anchor" id="Signal-manipulation-1" href="#Signal-manipulation-1">Signal manipulation</a></h1><p>There are several categories of signal manipulation: extending, cutting, filtering, ramping, and mapping.</p><h2><a class="nav-anchor" id="Extending-1" href="#Extending-1">Extending</a></h2><p>You can extend a signal using <a href="../reference/#SignalOperators.pad"><code>pad</code></a> or <a href="../reference/#SignalOperators.append"><code>append</code></a>. A padded signal becomes infinite and ends with the specified value, usually <code>one</code> or <code>zero</code>. You can append to or more signals (or <a href="@ref"><code>preprend</code></a>) so the occur one after another.</p><pre><code class="language-julia">pad(x,zero) |&gt; duration |&gt; isinf == true
append(x,y) |&gt; duration == duration(x) + duration(y)</code></pre><h2><a class="nav-anchor" id="Cutting-1" href="#Cutting-1">Cutting</a></h2><p>You can cut signals apart, removing either the end of the signal (<a href="../reference/#SignalOperators.until"><code>until</code></a>) or the beginning (<a href="../reference/#SignalOperators.after"><code>after</code></a>). The operations are exact compliments of one another.</p><pre><code class="language-julia">append(until(x,2s),after(x,2s)) |&gt; nsamples == nsamples(x)</code></pre><h2><a class="nav-anchor" id="Filtering-1" href="#Filtering-1">Filtering</a></h2><p>You can filter signals, removing undesired frequencies using <a href="../reference/#SignalOperators.lowpass"><code>lowpass</code></a>, <a href="../reference/#SignalOperators.highpass"><code>highpass</code></a>, <a href="../reference/#SignalOperators.bandpass"><code>bandpass</code></a>, <a href="../reference/#SignalOperators.bandstop"><code>bandstop</code></a> and <a href="../reference/#SignalOperators.filtersignal"><code>filtersignal</code></a>. The latter allows the use of any arbitrary filter defined using <code>DSP</code>. </p><pre><code class="language-julia">signal(randn) |&gt; lowpass(20Hz)</code></pre><p>Note that if you use <code>using DSP</code> you will have to also call <code>dB = SignalOperators.Units.dB</code> if you want to make use of the proper meaning of <code>dB</code> for <code>SignalOperators</code>: <code>DSP</code> also defined a value for <code>dB</code>.</p><p>A unusual filter is <a href="../reference/#SignalOperators.normpower"><code>normpower</code></a>: it computes the root mean squared power of the signal and then normalizes each sample by that value.</p><h2><a class="nav-anchor" id="Ramping-1" href="#Ramping-1">Ramping</a></h2><p>A ramp allows for smooth transition from 0 amplitude to the full amplitude of the signal. It is useful for avoid clicks in the onset or offset of a sound. For example, pure-tones are typically ramped when presented.</p><pre><code class="language-julia">signal(sin,ω=2kHz) |&gt; until(5s) |&gt; ramp</code></pre><p>You can ramp only the start of a signal (<a href="@ref"><code>rampon</code></a>), or the end of it (<a href="@ref"><code>rampoff</code></a>) and you can use ramps to create a smooth transition between two signals (<a href="@ref"><code>fadeto</code></a>). </p><h2><a class="nav-anchor" id="Mapping-1" href="#Mapping-1">Mapping</a></h2><p>Probably the most powerful operator is <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a>. It works a lot like <code>map</code> but automatically promotes the signals, as with all operators, <em>and</em> it pads the end of the signal appropriately, so different length signals can be combined. The output is always the length of the longest <em>finite</em>-length signal.</p><pre><code class="language-julia">a = signal(sin,ω=2kHz) |&gt; until(2s)
b = signal(sin,ω=1kHz) |&gt; until(3s)
a_minus_b = mapsignal(-,a,b)</code></pre><p>The function <code>mapsignal</code> cannot, itself be piped, due to ambigity in the arugments, but shortcuts for this function have been provided for addition <a href="../reference/#SignalOperators.mix"><code>mix</code></a>] and multiplication <a href="../reference/#SignalOperators.amplify"><code>amplify</code></a>], the two most common operations, and these two shortcuts have piped versions available.</p><pre><code class="language-julia">a_plus_b = mix(a,b)
a_times_b = amplify(a,b)</code></pre><p>You can add or select out channels using <a href="../reference/#SignalOperators.addchannel"><code>addchannel</code></a> and <a href="../reference/#SignalOperators.channel"><code>channel</code></a>, which are defined in terms of calls to <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a>. These use a variant of <code>mapsignal</code> where the keyword <code>across_channels</code> is defined as true (see <code>mapsignal</code>&#39;s documentation for details).</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../reference/"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
